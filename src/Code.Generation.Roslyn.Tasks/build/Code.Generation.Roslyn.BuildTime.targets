<?xml version="1.0" encoding="utf-8" ?>
<Project ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">

  <PropertyGroup>
    <CodeGenerationToolingFullName>dotnet-codegen</CodeGenerationToolingFullName>
    <CodeGenerationToolFullName>Code.Generation.Roslyn.Tool</CodeGenerationToolFullName>
    <CodeGenerationGeneratedExtension>.g</CodeGenerationGeneratedExtension>
    <CodeGenerationAssemblyReferenceExtension>.a</CodeGenerationAssemblyReferenceExtension>
    <CodeGenerationRegistryExtension>.json</CodeGenerationRegistryExtension>
    <CodeGenerationResponseFileExtension>.rsp</CodeGenerationResponseFileExtension>
    <GenerateCodeFromAttributesDependencies>
      PrepareCodeGenPropertyGroups
      ;PrepareToGenerateCodeFromAttributes
      ;InvokeCodeGenerationFromAttributes
      ;CompileCodeGenerationGeneratedCode
    </GenerateCodeFromAttributesDependencies>
  </PropertyGroup>

  <Target Name="PrepareCodeGenPropertyGroups">
    <PropertyGroup>
      <!-- So that we are not having to make any intermediate directories. -->
      <CodeGenToolIntermediateOutputDirectory>$(IntermediateOutputPath)</CodeGenToolIntermediateOutputDirectory>
      <CodeGenToolOutputBaseFileName>$(MSBuildProjectFile)</CodeGenToolOutputBaseFileName>
      <CodeGenToolGeneratedRegistryFileName>$(CodeGenToolOutputBaseFileName)$(CodeGenerationGeneratedExtension)$(CodeGenerationRegistryExtension)</CodeGenToolGeneratedRegistryFileName>
      <CodeGenToolCompilationRegistryPath>$(IntermediateOutputPath)$(CodeGenToolGeneratedRegistryFileName)</CodeGenToolCompilationRegistryPath>
      <CodeGenToolAssemblyReferenceRegistryFileName>$(CodeGenToolOutputBaseFileName)$(CodeGenerationAssemblyReferenceExtension)$(CodeGenerationRegistryExtension)</CodeGenToolAssemblyReferenceRegistryFileName>
      <CodeGenToolAssemblyReferenceRegistryPath>$(IntermediateOutputPath)$(CodeGenToolAssemblyReferenceRegistryFileName)</CodeGenToolAssemblyReferenceRegistryPath>
      <CodeGenToolCommandLineArgumentsResponseFileName>$(CodeGenToolOutputBaseFileName)$(CodeGenerationResponseFileExtension)</CodeGenToolCommandLineArgumentsResponseFileName>
      <CodeGenToolCommandLineArgumentsResponsePath>$(IntermediateOutputPath)$(CodeGenToolCommandLineArgumentsResponseFileName)</CodeGenToolCommandLineArgumentsResponsePath>
      <CodeGenToolCompilationResponseFileName>$(CodeGenToolOutputBaseFileName)$(CodeGenerationGeneratedExtension)$(CodeGenerationResponseFileExtension)</CodeGenToolCompilationResponseFileName>
      <CodeGenToolCompilationResponsePath>$(IntermediateOutputPath)$(CodeGenToolCompilationResponseFileName)</CodeGenToolCompilationResponsePath>
    </PropertyGroup>
  </Target>

  <Target Name="CleanCodeGenerationArtifacts" BeforeTargets="Clean">
    <PropertyGroup>
      <!-- TODO: TBD: we always depend on this as a base set of arguments. -->
      <!-- TODO: TBD: perhaps establish these up front as a first class CGR property. -->
      <_CodeGenToolResponseFileContent>
--project
$(MSBuildProjectDirectory)
--output
$(IntermediateOutputPath)
--generated
$(CodeGenToolGeneratedRegistryFileName)
--assemblies
$(CodeGenToolAssemblyReferenceRegistryFileName)
      </_CodeGenToolResponseFileContent>
    </PropertyGroup>
    <!-- Must make the Intermediate Output Directory because the invoking context may not have output directory comprehension. -->
    <MakeDir Directories="$(IntermediateOutputPath)" Condition="!Exists('$(IntermediateOutputPath)')" />
    <!-- Write the response file with arguments for dotnet-codegen. -->
    <WriteLinesToFile File="$(CodeGenToolCommandLineArgumentsResponsePath)" Lines="$(_CodeGenToolResponseFileContent)" Overwrite="true" />
    <Message Text="Evaluating `dotnet $(_DotnetCommandLineSwitches)$(DotnetCodeGenerationToolPath) --response &quot;$(CodeGenToolCommandLineArgumentsResponsePath)&quot;´ ..." Importance="high" />
    <Exec Command="dotnet $(_DotnetCommandLineSwitches)$(DotnetCodeGenerationToolPath) --response &quot;$(CodeGenToolCommandLineArgumentsResponsePath)&quot;" ConsoleToMSBuild="true" StandardOutputImportance="normal" ContinueOnError="true" />
  </Target>

  <PropertyGroup>
    <!-- Which the `tool´ build needs to yield literally, `dotnet-codegen´ for its assembly output. -->
    <DotnetCodeGenerationToolPath Condition="'$(DotnetCodeGenerationToolPath)' == ''">codegen</DotnetCodeGenerationToolPath>
    <DotnetCommandLineSwitches Condition="'$(DotnetCommandLineSwitches)' != ''"></DotnetCommandLineSwitches>
  </PropertyGroup>

  <!-- Rolls up the Targets into the front-facing Code Generation Target. -->
  <Target Name="GenerateCodeFromAttributes" DependsOnTargets="$(GenerateCodeFromAttributesDependencies)" BeforeTargets="CoreCompile;PrepareResources" />

  <!-- ReSharper disable once UnknownTarget -->
  <Target Name="PrepareToGenerateCodeFromAttributes" DependsOnTargets="ResolveReferences;PrepareCodeGenPropertyGroups">
    <Message Text="Preparing to run code generation using intermediate directory `$(IntermediateOutputPath)´ ..." Importance="high" />
    <ItemGroup>
      <!-- ReSharper disable once UnknownProperty -->
      <CodeGenCompilationDefineConstants Include="$(DefineConstants)" />
      <CodeGenCompilationInputsFromAttributes Include="@(Compile)" Condition="'%(Compile.Generator)' == 'MSBuild:GenerateCodeFromAttributes'" />
    </ItemGroup>
    <PropertyGroup>
      <!-- Literally, Response File lines separated by Carriage Return Line Feed. -->
      <_CgrSep>%0d%0a</_CgrSep>
      <!-- TODO: TBD: may refactor this to the actual invocation since it reallyhas nothing to do with `preparation´ or `identifying tooling versions´... -->
      <!-- ReSharper disable once UnknownItemGroup -->
      <_CodeGenToolResponseFileContent>
--project
$(MSBuildProjectDirectory)
--output
$(IntermediateOutputPath)
--generated
$(CodeGenToolGeneratedRegistryFileName)
--assemblies
$(CodeGenToolAssemblyReferenceRegistryFileName)@(ReferencePath->'$(_CgrSep)--reference$(_CgrSep)%(Identity)', '')@(CodeGenCompilationDefineConstants->'$(_CgrSep)--define$(_CgrSep)%(Identity)', '')@(GeneratorAssemblySearchPaths->'$(_CgrSep)--search$(_CgrSep)%(Identity)', '')@(CodeGenCompilationInputsFromAttributes->'$(_CgrSep)--source$(_CgrSep)%(Identity)', '')
      </_CodeGenToolResponseFileContent>
      <!--<_CodeGenToolResponseFileContent Condition="'$(GeneratorAssemblySearchPaths)' != ''">$(_CodeGenToolResponseFileContent)</_CodeGenToolResponseFileContent>-->
      <_GenerateCodeToolVersion>(n/a)</_GenerateCodeToolVersion>
      <_DotnetCommandLineSwitches>$(DotnetCommandLineSwitches) </_DotnetCommandLineSwitches>
    </PropertyGroup>
    <!-- Must make the Intermediate Output Directory because the invoking context may not have output directory comprehension. -->
    <MakeDir Directories="$(IntermediateOutputPath)" Condition="!Exists('$(IntermediateOutputPath)')" />
    <!-- Write the response file with arguments for dotnet-codegen. -->
    <WriteLinesToFile File="$(CodeGenToolCommandLineArgumentsResponsePath)" Lines="$(_CodeGenToolResponseFileContent)" Overwrite="true" />
    <!-- TODO: TBD: for now, do not delete the Compilation Registry... This helps preclude unnecessarily regenerating code... -->
    <!-- TODO: TBD: if anything, maybe we also respond to 'Clean' target requests in order to do this bit... -->
    <!--<Delete Condition="Exists('$(CodeGenToolCompilationRegistryPath)')" Files="$(CodeGenToolCompilationRegistryPath)" ContinueOnError="true" />-->
    <!-- Verify and report the tool version. -->
    <Message Text="Evaluating `dotnet $(_DotnetCommandLineSwitches)$(DotnetCodeGenerationToolPath) --version´ ..." Importance="high" />
    <Exec Command="dotnet $(_DotnetCommandLineSwitches)$(DotnetCodeGenerationToolPath) --version" ConsoleToMSBuild="true" StandardOutputImportance="normal" ContinueOnError="true">
      <Output TaskParameter="ConsoleOutput" PropertyName="_GenerateCodeToolVersion" />
    </Exec>
    <Message Text="Running $(CodeGenerationToolFullName) v$(_GenerateCodeToolVersion) ..." Importance="high" />
  </Target>

  <Target Name="InvokeCodeGenerationFromAttributes" DependsOnTargets="PrepareToGenerateCodeFromAttributes" Condition="'@(CodeGenCompilationInputsFromAttributes)' != ''">
    <PropertyGroup>
      <_CgrWarning>CGR1000</_CgrWarning>
      <_CodeGenToolWarningText>$(CodeGenerationToolingFullName): Failed to yield code generation artifacts, please check https://github.com/mwpowellhtx/Code.Generation.Roslyn for usage instructions.</_CodeGenToolWarningText>
    </PropertyGroup>
    <!-- Run the tool using the Response File, which we do need an Argument for, and evaluate the expected outcome. -->
    <Message Text="Evaluating `dotnet $(_DotnetCommandLineSwitches)$(DotnetCodeGenerationToolPath) --response &quot;$(CodeGenToolCommandLineArgumentsResponsePath)&quot;´ ..." Importance="high" />
    <Exec Command="dotnet $(_DotnetCommandLineSwitches)$(DotnetCodeGenerationToolPath) --response &quot;$(CodeGenToolCommandLineArgumentsResponsePath)&quot;" ConsoleToMSBuild="true" StandardOutputImportance="normal" ContinueOnError="true" />
    <Warning Code="$(_CgrWarning)" Text="$(_CodeGenToolWarningText)" Condition="!(Exists('$(CodeGenToolCompilationRegistryPath)') And Exists('$(CodeGenToolCompilationResponsePath)') And Exists('$(CodeGenToolAssemblyReferenceRegistryPath))'))" />
  </Target>

  <Target Name="CompileCodeGenerationGeneratedCode" DependsOnTargets="InvokeCodeGenerationFromAttributes" Condition="Exists('$(CodeGenToolCompilationResponsePath)')">
    <ReadLinesFromFile File="$(CodeGenToolCompilationResponsePath)">
      <Output TaskParameter="Lines" ItemName="_CodeGenToolCompilationGeneratedInputFiles" />
    </ReadLinesFromFile>
    <ReadLinesFromFile File="$(CodeGenToolCompilationResponsePath)">
      <Output TaskParameter="Lines" ItemName="FileWrites" />
    </ReadLinesFromFile>
    <ItemGroup>
      <Compile Include="@(_CodeGenToolCompilationGeneratedInputFiles)" />
      <FileWrites Include="$(CodeGenToolCompilationResponsePath)" />
    </ItemGroup>
  </Target>

</Project>
